package converter

// Code generated by peg converter/converter.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleletters
	ruleletter
	rulealphabet
	rulelargeA
	rulelargeB
	rulelargeC
	rulelargeD
	rulelargeE
	rulelargeF
	rulelargeG
	rulelargeH
	rulelargeI
	rulelargeJ
	rulelargeK
	rulelargeL
	rulelargeM
	rulelargeN
	rulelargeO
	rulelargeP
	rulelargeQ
	rulelargeR
	rulelargeS
	rulelargeT
	rulelargeU
	rulelargeV
	rulelargeW
	rulelargeX
	rulelargeY
	rulelargeZ
	rulesmallA
	rulesmallB
	rulesmallC
	rulesmallD
	rulesmallE
	rulesmallF
	rulesmallG
	rulesmallH
	rulesmallI
	rulesmallJ
	rulesmallK
	rulesmallL
	rulesmallM
	rulesmallN
	rulesmallO
	rulesmallP
	rulesmallQ
	rulesmallR
	rulesmallS
	rulesmallT
	rulesmallU
	rulesmallV
	rulesmallW
	rulesmallX
	rulesmallY
	rulesmallZ
	rulenonAlphabet
	ruledollar
	rulebackQuote
	rulecolon
	ruleleftGuillemet
	rulerightGuillemet
	rulequestion
	ruleexclamation
	ruleasis
)

var rul3s = [...]string{
	"Unknown",
	"letters",
	"letter",
	"alphabet",
	"largeA",
	"largeB",
	"largeC",
	"largeD",
	"largeE",
	"largeF",
	"largeG",
	"largeH",
	"largeI",
	"largeJ",
	"largeK",
	"largeL",
	"largeM",
	"largeN",
	"largeO",
	"largeP",
	"largeQ",
	"largeR",
	"largeS",
	"largeT",
	"largeU",
	"largeV",
	"largeW",
	"largeX",
	"largeY",
	"largeZ",
	"smallA",
	"smallB",
	"smallC",
	"smallD",
	"smallE",
	"smallF",
	"smallG",
	"smallH",
	"smallI",
	"smallJ",
	"smallK",
	"smallL",
	"smallM",
	"smallN",
	"smallO",
	"smallP",
	"smallQ",
	"smallR",
	"smallS",
	"smallT",
	"smallU",
	"smallV",
	"smallW",
	"smallX",
	"smallY",
	"smallZ",
	"nonAlphabet",
	"dollar",
	"backQuote",
	"colon",
	"leftGuillemet",
	"rightGuillemet",
	"question",
	"exclamation",
	"asis",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Converter struct {
	Buffer string
	buffer []rune
	rules  [65]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Converter) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Converter) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Converter
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Converter) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Converter) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Converter) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*Converter) error {
	return func(p *Converter) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Converter) error {
	return func(p *Converter) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Converter) Init(options ...func(*Converter) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 letters <- <letter*> */
		func() bool {
			{
				position1 := position
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleletter]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				add(ruleletters, position1)
			}
			return true
		},
		/* 1 letter <- <(alphabet / nonAlphabet / asis)> */
		func() bool {
			position4, tokenIndex4 := position, tokenIndex
			{
				position5 := position
				{
					position6, tokenIndex6 := position, tokenIndex
					if !_rules[rulealphabet]() {
						goto l7
					}
					goto l6
				l7:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[rulenonAlphabet]() {
						goto l8
					}
					goto l6
				l8:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleasis]() {
						goto l4
					}
				}
			l6:
				add(ruleletter, position5)
			}
			return true
		l4:
			position, tokenIndex = position4, tokenIndex4
			return false
		},
		/* 2 alphabet <- <(largeA / largeB / largeC / largeD / largeE / largeF / largeG / largeH / largeI / largeJ / largeK / largeL / largeM / largeN / largeO / largeP / largeQ / largeR / largeS / largeT / largeU / largeV / largeW / largeX / largeY / largeZ / smallA / smallB / smallC / smallD / smallE / smallF / smallG / smallH / smallI / smallJ / smallK / smallL / smallM / smallN / smallO / smallP / smallQ / smallR / smallS / smallT / smallU / smallV / smallW / smallX / smallY / smallZ)> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !_rules[rulelargeA]() {
						goto l12
					}
					goto l11
				l12:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeB]() {
						goto l13
					}
					goto l11
				l13:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeC]() {
						goto l14
					}
					goto l11
				l14:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeD]() {
						goto l15
					}
					goto l11
				l15:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeE]() {
						goto l16
					}
					goto l11
				l16:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeF]() {
						goto l17
					}
					goto l11
				l17:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeG]() {
						goto l18
					}
					goto l11
				l18:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeH]() {
						goto l19
					}
					goto l11
				l19:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeI]() {
						goto l20
					}
					goto l11
				l20:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeJ]() {
						goto l21
					}
					goto l11
				l21:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeK]() {
						goto l22
					}
					goto l11
				l22:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeL]() {
						goto l23
					}
					goto l11
				l23:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeM]() {
						goto l24
					}
					goto l11
				l24:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeN]() {
						goto l25
					}
					goto l11
				l25:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeO]() {
						goto l26
					}
					goto l11
				l26:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeP]() {
						goto l27
					}
					goto l11
				l27:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeQ]() {
						goto l28
					}
					goto l11
				l28:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeR]() {
						goto l29
					}
					goto l11
				l29:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeS]() {
						goto l30
					}
					goto l11
				l30:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeT]() {
						goto l31
					}
					goto l11
				l31:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeU]() {
						goto l32
					}
					goto l11
				l32:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeV]() {
						goto l33
					}
					goto l11
				l33:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeW]() {
						goto l34
					}
					goto l11
				l34:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeX]() {
						goto l35
					}
					goto l11
				l35:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeY]() {
						goto l36
					}
					goto l11
				l36:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulelargeZ]() {
						goto l37
					}
					goto l11
				l37:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallA]() {
						goto l38
					}
					goto l11
				l38:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallB]() {
						goto l39
					}
					goto l11
				l39:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallC]() {
						goto l40
					}
					goto l11
				l40:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallD]() {
						goto l41
					}
					goto l11
				l41:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallE]() {
						goto l42
					}
					goto l11
				l42:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallF]() {
						goto l43
					}
					goto l11
				l43:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallG]() {
						goto l44
					}
					goto l11
				l44:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallH]() {
						goto l45
					}
					goto l11
				l45:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallI]() {
						goto l46
					}
					goto l11
				l46:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallJ]() {
						goto l47
					}
					goto l11
				l47:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallK]() {
						goto l48
					}
					goto l11
				l48:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallL]() {
						goto l49
					}
					goto l11
				l49:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallM]() {
						goto l50
					}
					goto l11
				l50:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallN]() {
						goto l51
					}
					goto l11
				l51:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallO]() {
						goto l52
					}
					goto l11
				l52:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallP]() {
						goto l53
					}
					goto l11
				l53:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallQ]() {
						goto l54
					}
					goto l11
				l54:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallR]() {
						goto l55
					}
					goto l11
				l55:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallS]() {
						goto l56
					}
					goto l11
				l56:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallT]() {
						goto l57
					}
					goto l11
				l57:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallU]() {
						goto l58
					}
					goto l11
				l58:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallV]() {
						goto l59
					}
					goto l11
				l59:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallW]() {
						goto l60
					}
					goto l11
				l60:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallX]() {
						goto l61
					}
					goto l11
				l61:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallY]() {
						goto l62
					}
					goto l11
				l62:
					position, tokenIndex = position11, tokenIndex11
					if !_rules[rulesmallZ]() {
						goto l9
					}
				}
			l11:
				add(rulealphabet, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 3 largeA <- <'A'> */
		func() bool {
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				if buffer[position] != rune('A') {
					goto l63
				}
				position++
				add(rulelargeA, position64)
			}
			return true
		l63:
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 4 largeB <- <'B'> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				if buffer[position] != rune('B') {
					goto l65
				}
				position++
				add(rulelargeB, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 5 largeC <- <('C' ('h' / '\'')?)> */
		func() bool {
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				if buffer[position] != rune('C') {
					goto l67
				}
				position++
				{
					position69, tokenIndex69 := position, tokenIndex
					{
						position71, tokenIndex71 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l72
						}
						position++
						goto l71
					l72:
						position, tokenIndex = position71, tokenIndex71
						if buffer[position] != rune('\'') {
							goto l69
						}
						position++
					}
				l71:
					goto l70
				l69:
					position, tokenIndex = position69, tokenIndex69
				}
			l70:
				add(rulelargeC, position68)
			}
			return true
		l67:
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 6 largeD <- <('D' 'z'?)> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				if buffer[position] != rune('D') {
					goto l73
				}
				position++
				{
					position75, tokenIndex75 := position, tokenIndex
					if buffer[position] != rune('z') {
						goto l75
					}
					position++
					goto l76
				l75:
					position, tokenIndex = position75, tokenIndex75
				}
			l76:
				add(rulelargeD, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 7 largeE <- <('E' '\''?)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if buffer[position] != rune('E') {
					goto l77
				}
				position++
				{
					position79, tokenIndex79 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l79
					}
					position++
					goto l80
				l79:
					position, tokenIndex = position79, tokenIndex79
				}
			l80:
				add(rulelargeE, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 8 largeF <- <'F'> */
		func() bool {
			position81, tokenIndex81 := position, tokenIndex
			{
				position82 := position
				if buffer[position] != rune('F') {
					goto l81
				}
				position++
				add(rulelargeF, position82)
			}
			return true
		l81:
			position, tokenIndex = position81, tokenIndex81
			return false
		},
		/* 9 largeG <- <('G' 'h'?)> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				if buffer[position] != rune('G') {
					goto l83
				}
				position++
				{
					position85, tokenIndex85 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l85
					}
					position++
					goto l86
				l85:
					position, tokenIndex = position85, tokenIndex85
				}
			l86:
				add(rulelargeG, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 10 largeH <- <'H'> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				if buffer[position] != rune('H') {
					goto l87
				}
				position++
				add(rulelargeH, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 11 largeI <- <'I'> */
		func() bool {
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				if buffer[position] != rune('I') {
					goto l89
				}
				position++
				add(rulelargeI, position90)
			}
			return true
		l89:
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 12 largeJ <- <'J'> */
		func() bool {
			position91, tokenIndex91 := position, tokenIndex
			{
				position92 := position
				if buffer[position] != rune('J') {
					goto l91
				}
				position++
				add(rulelargeJ, position92)
			}
			return true
		l91:
			position, tokenIndex = position91, tokenIndex91
			return false
		},
		/* 13 largeK <- <'K'> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				if buffer[position] != rune('K') {
					goto l93
				}
				position++
				add(rulelargeK, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 14 largeL <- <'L'> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				if buffer[position] != rune('L') {
					goto l95
				}
				position++
				add(rulelargeL, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 15 largeM <- <'M'> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				if buffer[position] != rune('M') {
					goto l97
				}
				position++
				add(rulelargeM, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 16 largeN <- <'N'> */
		func() bool {
			position99, tokenIndex99 := position, tokenIndex
			{
				position100 := position
				if buffer[position] != rune('N') {
					goto l99
				}
				position++
				add(rulelargeN, position100)
			}
			return true
		l99:
			position, tokenIndex = position99, tokenIndex99
			return false
		},
		/* 17 largeO <- <'O'> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				if buffer[position] != rune('O') {
					goto l101
				}
				position++
				add(rulelargeO, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 18 largeP <- <('P' '\''?)> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				if buffer[position] != rune('P') {
					goto l103
				}
				position++
				{
					position105, tokenIndex105 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l105
					}
					position++
					goto l106
				l105:
					position, tokenIndex = position105, tokenIndex105
				}
			l106:
				add(rulelargeP, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 19 largeQ <- <'Q'> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				if buffer[position] != rune('Q') {
					goto l107
				}
				position++
				add(rulelargeQ, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 20 largeR <- <('R' 'r'?)> */
		func() bool {
			position109, tokenIndex109 := position, tokenIndex
			{
				position110 := position
				if buffer[position] != rune('R') {
					goto l109
				}
				position++
				{
					position111, tokenIndex111 := position, tokenIndex
					if buffer[position] != rune('r') {
						goto l111
					}
					position++
					goto l112
				l111:
					position, tokenIndex = position111, tokenIndex111
				}
			l112:
				add(rulelargeR, position110)
			}
			return true
		l109:
			position, tokenIndex = position109, tokenIndex109
			return false
		},
		/* 21 largeS <- <('S' 'h'?)> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				if buffer[position] != rune('S') {
					goto l113
				}
				position++
				{
					position115, tokenIndex115 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l115
					}
					position++
					goto l116
				l115:
					position, tokenIndex = position115, tokenIndex115
				}
			l116:
				add(rulelargeS, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 22 largeT <- <('T' ('w' / '\'')?)> */
		func() bool {
			position117, tokenIndex117 := position, tokenIndex
			{
				position118 := position
				if buffer[position] != rune('T') {
					goto l117
				}
				position++
				{
					position119, tokenIndex119 := position, tokenIndex
					{
						position121, tokenIndex121 := position, tokenIndex
						if buffer[position] != rune('w') {
							goto l122
						}
						position++
						goto l121
					l122:
						position, tokenIndex = position121, tokenIndex121
						if buffer[position] != rune('\'') {
							goto l119
						}
						position++
					}
				l121:
					goto l120
				l119:
					position, tokenIndex = position119, tokenIndex119
				}
			l120:
				add(rulelargeT, position118)
			}
			return true
		l117:
			position, tokenIndex = position117, tokenIndex117
			return false
		},
		/* 23 largeU <- <'U'> */
		func() bool {
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				if buffer[position] != rune('U') {
					goto l123
				}
				position++
				add(rulelargeU, position124)
			}
			return true
		l123:
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 24 largeV <- <('V' 'o'?)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				if buffer[position] != rune('V') {
					goto l125
				}
				position++
				{
					position127, tokenIndex127 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l127
					}
					position++
					goto l128
				l127:
					position, tokenIndex = position127, tokenIndex127
				}
			l128:
				add(rulelargeV, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 25 largeW <- <'W'> */
		func() bool {
			position129, tokenIndex129 := position, tokenIndex
			{
				position130 := position
				if buffer[position] != rune('W') {
					goto l129
				}
				position++
				add(rulelargeW, position130)
			}
			return true
		l129:
			position, tokenIndex = position129, tokenIndex129
			return false
		},
		/* 26 largeX <- <'X'> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune('X') {
					goto l131
				}
				position++
				add(rulelargeX, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 27 largeY <- <('Y' '\''?)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if buffer[position] != rune('Y') {
					goto l133
				}
				position++
				{
					position135, tokenIndex135 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l135
					}
					position++
					goto l136
				l135:
					position, tokenIndex = position135, tokenIndex135
				}
			l136:
				add(rulelargeY, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 28 largeZ <- <('Z' 'h'?)> */
		func() bool {
			position137, tokenIndex137 := position, tokenIndex
			{
				position138 := position
				if buffer[position] != rune('Z') {
					goto l137
				}
				position++
				{
					position139, tokenIndex139 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l139
					}
					position++
					goto l140
				l139:
					position, tokenIndex = position139, tokenIndex139
				}
			l140:
				add(rulelargeZ, position138)
			}
			return true
		l137:
			position, tokenIndex = position137, tokenIndex137
			return false
		},
		/* 29 smallA <- <'a'> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				if buffer[position] != rune('a') {
					goto l141
				}
				position++
				add(rulesmallA, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 30 smallB <- <'b'> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if buffer[position] != rune('b') {
					goto l143
				}
				position++
				add(rulesmallB, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 31 smallC <- <('c' ('h' / '\'')?)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('c') {
					goto l145
				}
				position++
				{
					position147, tokenIndex147 := position, tokenIndex
					{
						position149, tokenIndex149 := position, tokenIndex
						if buffer[position] != rune('h') {
							goto l150
						}
						position++
						goto l149
					l150:
						position, tokenIndex = position149, tokenIndex149
						if buffer[position] != rune('\'') {
							goto l147
						}
						position++
					}
				l149:
					goto l148
				l147:
					position, tokenIndex = position147, tokenIndex147
				}
			l148:
				add(rulesmallC, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 32 smallD <- <('d' 'z'?)> */
		func() bool {
			position151, tokenIndex151 := position, tokenIndex
			{
				position152 := position
				if buffer[position] != rune('d') {
					goto l151
				}
				position++
				{
					position153, tokenIndex153 := position, tokenIndex
					if buffer[position] != rune('z') {
						goto l153
					}
					position++
					goto l154
				l153:
					position, tokenIndex = position153, tokenIndex153
				}
			l154:
				add(rulesmallD, position152)
			}
			return true
		l151:
			position, tokenIndex = position151, tokenIndex151
			return false
		},
		/* 33 smallE <- <('e' ('v' / '\'')?)> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				if buffer[position] != rune('e') {
					goto l155
				}
				position++
				{
					position157, tokenIndex157 := position, tokenIndex
					{
						position159, tokenIndex159 := position, tokenIndex
						if buffer[position] != rune('v') {
							goto l160
						}
						position++
						goto l159
					l160:
						position, tokenIndex = position159, tokenIndex159
						if buffer[position] != rune('\'') {
							goto l157
						}
						position++
					}
				l159:
					goto l158
				l157:
					position, tokenIndex = position157, tokenIndex157
				}
			l158:
				add(rulesmallE, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 34 smallF <- <'f'> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				if buffer[position] != rune('f') {
					goto l161
				}
				position++
				add(rulesmallF, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 35 smallG <- <('g' 'h'?)> */
		func() bool {
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				if buffer[position] != rune('g') {
					goto l163
				}
				position++
				{
					position165, tokenIndex165 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l165
					}
					position++
					goto l166
				l165:
					position, tokenIndex = position165, tokenIndex165
				}
			l166:
				add(rulesmallG, position164)
			}
			return true
		l163:
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 36 smallH <- <'h'> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				if buffer[position] != rune('h') {
					goto l167
				}
				position++
				add(rulesmallH, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 37 smallI <- <'i'> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				if buffer[position] != rune('i') {
					goto l169
				}
				position++
				add(rulesmallI, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 38 smallJ <- <'j'> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				if buffer[position] != rune('j') {
					goto l171
				}
				position++
				add(rulesmallJ, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 39 smallK <- <'k'> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('k') {
					goto l173
				}
				position++
				add(rulesmallK, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 40 smallL <- <'l'> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				if buffer[position] != rune('l') {
					goto l175
				}
				position++
				add(rulesmallL, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 41 smallM <- <'m'> */
		func() bool {
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				if buffer[position] != rune('m') {
					goto l177
				}
				position++
				add(rulesmallM, position178)
			}
			return true
		l177:
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 42 smallN <- <'n'> */
		func() bool {
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				if buffer[position] != rune('n') {
					goto l179
				}
				position++
				add(rulesmallN, position180)
			}
			return true
		l179:
			position, tokenIndex = position179, tokenIndex179
			return false
		},
		/* 43 smallO <- <'o'> */
		func() bool {
			position181, tokenIndex181 := position, tokenIndex
			{
				position182 := position
				if buffer[position] != rune('o') {
					goto l181
				}
				position++
				add(rulesmallO, position182)
			}
			return true
		l181:
			position, tokenIndex = position181, tokenIndex181
			return false
		},
		/* 44 smallP <- <('p' '\''?)> */
		func() bool {
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if buffer[position] != rune('p') {
					goto l183
				}
				position++
				{
					position185, tokenIndex185 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l185
					}
					position++
					goto l186
				l185:
					position, tokenIndex = position185, tokenIndex185
				}
			l186:
				add(rulesmallP, position184)
			}
			return true
		l183:
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 45 smallQ <- <'q'> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if buffer[position] != rune('q') {
					goto l187
				}
				position++
				add(rulesmallQ, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 46 smallR <- <('r' 'r'?)> */
		func() bool {
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				if buffer[position] != rune('r') {
					goto l189
				}
				position++
				{
					position191, tokenIndex191 := position, tokenIndex
					if buffer[position] != rune('r') {
						goto l191
					}
					position++
					goto l192
				l191:
					position, tokenIndex = position191, tokenIndex191
				}
			l192:
				add(rulesmallR, position190)
			}
			return true
		l189:
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 47 smallS <- <('s' 'h'?)> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				if buffer[position] != rune('s') {
					goto l193
				}
				position++
				{
					position195, tokenIndex195 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l195
					}
					position++
					goto l196
				l195:
					position, tokenIndex = position195, tokenIndex195
				}
			l196:
				add(rulesmallS, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 48 smallT <- <('t' ('w' / '\'')?)> */
		func() bool {
			position197, tokenIndex197 := position, tokenIndex
			{
				position198 := position
				if buffer[position] != rune('t') {
					goto l197
				}
				position++
				{
					position199, tokenIndex199 := position, tokenIndex
					{
						position201, tokenIndex201 := position, tokenIndex
						if buffer[position] != rune('w') {
							goto l202
						}
						position++
						goto l201
					l202:
						position, tokenIndex = position201, tokenIndex201
						if buffer[position] != rune('\'') {
							goto l199
						}
						position++
					}
				l201:
					goto l200
				l199:
					position, tokenIndex = position199, tokenIndex199
				}
			l200:
				add(rulesmallT, position198)
			}
			return true
		l197:
			position, tokenIndex = position197, tokenIndex197
			return false
		},
		/* 49 smallU <- <'u'> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				if buffer[position] != rune('u') {
					goto l203
				}
				position++
				add(rulesmallU, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 50 smallV <- <('v' 'o'?)> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				if buffer[position] != rune('v') {
					goto l205
				}
				position++
				{
					position207, tokenIndex207 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l207
					}
					position++
					goto l208
				l207:
					position, tokenIndex = position207, tokenIndex207
				}
			l208:
				add(rulesmallV, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 51 smallW <- <'w'> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if buffer[position] != rune('w') {
					goto l209
				}
				position++
				add(rulesmallW, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 52 smallX <- <'x'> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if buffer[position] != rune('x') {
					goto l211
				}
				position++
				add(rulesmallX, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 53 smallY <- <('y' '\''?)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if buffer[position] != rune('y') {
					goto l213
				}
				position++
				{
					position215, tokenIndex215 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l215
					}
					position++
					goto l216
				l215:
					position, tokenIndex = position215, tokenIndex215
				}
			l216:
				add(rulesmallY, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 54 smallZ <- <('z' 'h'?)> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if buffer[position] != rune('z') {
					goto l217
				}
				position++
				{
					position219, tokenIndex219 := position, tokenIndex
					if buffer[position] != rune('h') {
						goto l219
					}
					position++
					goto l220
				l219:
					position, tokenIndex = position219, tokenIndex219
				}
			l220:
				add(rulesmallZ, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 55 nonAlphabet <- <(dollar / backQuote / colon / leftGuillemet / rightGuillemet / question / exclamation)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				{
					position223, tokenIndex223 := position, tokenIndex
					if !_rules[ruledollar]() {
						goto l224
					}
					goto l223
				l224:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[rulebackQuote]() {
						goto l225
					}
					goto l223
				l225:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[rulecolon]() {
						goto l226
					}
					goto l223
				l226:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[ruleleftGuillemet]() {
						goto l227
					}
					goto l223
				l227:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[rulerightGuillemet]() {
						goto l228
					}
					goto l223
				l228:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[rulequestion]() {
						goto l229
					}
					goto l223
				l229:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[ruleexclamation]() {
						goto l221
					}
				}
			l223:
				add(rulenonAlphabet, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 56 dollar <- <'$'> */
		func() bool {
			position230, tokenIndex230 := position, tokenIndex
			{
				position231 := position
				if buffer[position] != rune('$') {
					goto l230
				}
				position++
				add(ruledollar, position231)
			}
			return true
		l230:
			position, tokenIndex = position230, tokenIndex230
			return false
		},
		/* 57 backQuote <- <'`'> */
		func() bool {
			position232, tokenIndex232 := position, tokenIndex
			{
				position233 := position
				if buffer[position] != rune('`') {
					goto l232
				}
				position++
				add(rulebackQuote, position233)
			}
			return true
		l232:
			position, tokenIndex = position232, tokenIndex232
			return false
		},
		/* 58 colon <- <':'> */
		func() bool {
			position234, tokenIndex234 := position, tokenIndex
			{
				position235 := position
				if buffer[position] != rune(':') {
					goto l234
				}
				position++
				add(rulecolon, position235)
			}
			return true
		l234:
			position, tokenIndex = position234, tokenIndex234
			return false
		},
		/* 59 leftGuillemet <- <('<' '<')> */
		func() bool {
			position236, tokenIndex236 := position, tokenIndex
			{
				position237 := position
				if buffer[position] != rune('<') {
					goto l236
				}
				position++
				if buffer[position] != rune('<') {
					goto l236
				}
				position++
				add(ruleleftGuillemet, position237)
			}
			return true
		l236:
			position, tokenIndex = position236, tokenIndex236
			return false
		},
		/* 60 rightGuillemet <- <('>' '>')> */
		func() bool {
			position238, tokenIndex238 := position, tokenIndex
			{
				position239 := position
				if buffer[position] != rune('>') {
					goto l238
				}
				position++
				if buffer[position] != rune('>') {
					goto l238
				}
				position++
				add(rulerightGuillemet, position239)
			}
			return true
		l238:
			position, tokenIndex = position238, tokenIndex238
			return false
		},
		/* 61 question <- <'?'> */
		func() bool {
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				if buffer[position] != rune('?') {
					goto l240
				}
				position++
				add(rulequestion, position241)
			}
			return true
		l240:
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 62 exclamation <- <('!' '~'?)> */
		func() bool {
			position242, tokenIndex242 := position, tokenIndex
			{
				position243 := position
				if buffer[position] != rune('!') {
					goto l242
				}
				position++
				{
					position244, tokenIndex244 := position, tokenIndex
					if buffer[position] != rune('~') {
						goto l244
					}
					position++
					goto l245
				l244:
					position, tokenIndex = position244, tokenIndex244
				}
			l245:
				add(ruleexclamation, position243)
			}
			return true
		l242:
			position, tokenIndex = position242, tokenIndex242
			return false
		},
		/* 63 asis <- <.> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				if !matchDot() {
					goto l246
				}
				add(ruleasis, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
	}
	p.rules = _rules
	return nil
}
